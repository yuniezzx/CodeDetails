### 1.命名规则

 Rust 命名规则的基本指导原则：

1. 变量和函数名: 通常使用小写字母，并使用下划线分隔单词，例如 `my_variable` 和 `print_hello`。
2. 常量名: 使用全大写字母，并使用下划线分隔单词，例如 `PI` 和 `MAX_VALUE`。
3. 类型名: 使用驼峰命名法，首字母大写，例如 `MyStruct` 和 `MyEnum`。
4. 模块名和文件名: 使用小写字母，并使用下划线分隔单词。模块名和文件名通常保持一致，例如模块 `my_module` 对应的文件名为 `my_module.rs`。
5. 泛型参数: 通常使用大写字母表示，例如 `T` 和 `U`。在类型名称中，泛型参数通常紧跟在类型名称之后，例如 `Vec<T>`。
6. 生命周期参数: 生命周期参数的名称通常以 `'` 开头，后面跟一个小写字母，例如 `'a` 和 `'b`。
7. 宏名: 宏名使用小写字母，并使用下划线分隔单词。与函数名类似，但在宏名后加感叹号以表示宏，例如 `my_macro!`。

请注意，这些规则并非强制性的，但遵循这些惯例将有助于保持代码的一致性和可读性。


### 2.变量绑定,覆盖和解构



在 Rust 中，变量绑定是使用 `let` 关键字创建的。当你创建一个新的变量绑定时，你将一个值绑定到一个变量名。默认情况下，Rust 中的变量绑定是不可变的，这意味着一旦你给它们赋值，就不能改变它们的值。然而，**你可以使用 `mut` 关键字使变量绑定可变 ** 。

当你在同一作用域内用相同的变量名创建一个新的变量绑定时，新的变量绑定将“覆盖”或“阴影”先前的绑定。



```rust
fn main() {
    let x = 5;
    println!("x: {}", x);

    let x = x + 1;
    println!("x: {}", x);

    let x = x * 2;
    println!("x: {}", x);
}

```



在 Rust 中，解构允许你将复杂的数据结构分解为更简单的部分。这对于从结构体、元组、枚举等类型中提取值非常有用。通过使用模式匹配，你可以将变量解构为它们的组成部分。



```rust
// 解构元组：

fn main() {
    let tuple = (1, "hello", 3.14);

    let (x, y, z) = tuple;

    println!("x: {}, y: {}, z: {}", x, y, z);
}

```



```rust
// 解构结构体：

enum Animal {
    Dog { name: String, age: u8 },
    Cat { name: String, age: u8 },
}

fn main() {
    let animal = Animal::Dog {
        name: String::from("Max"),
        age: 3,
    };

    match animal {
        Animal::Dog { name, age } => println!("Dog's name: {}, age: {}", name, age),
        Animal::Cat { name, age } => println!("Cat's name: {}, age: {}", name, age),
    }
}
```



在 Rust 解构中，`..` 用于模式匹配中的范围。在解构赋值的情况下，使用 `..` 表示你想要忽略剩余的部分，使用 `_` 来表示我们不关心的值。

```rust
fn main() {
  	let (a, b, c, d, e);
    let (x, _) = (3, 4);
    let [_, y] = [1, 2];
  
  	[c, .., d, _] = [1, 2, 3, 4, 5];

    println!("x: {}, y: {}", x, y);  // x: 3, y: 2
}
```


### 3.变量作用域

变量的作用域是变量绑定在程序中生效的区域。变量作用域遵循块作用域规则，这意味着变量的生命周期从声明它的地方开始，到包含它的最近的块（用大括号 `{}` 包围的区域）结束。

在 Rust 中，内部作用域可以访问外部（包含）作用域中定义的变量。也就是说，如果一个变量在外部作用域中声明，那么在该作用域内的所有内部（嵌套）作用域中，该变量都是可见且可访问的。请注意，这并不意味着你可以在内部作用域中修改外部作用域的不可变变量。

```rust
fn main() {
    let x: i32 = 10;
    {
        let y: i32 = 5;
        println!("x 的值是 {}, y 的值是 {}", x, y);
    }
    let y: i32 = 5;
    println!("x 的值是 {}, y 的值是 {}", x, y); 
}
```


### 基本类型



基本类型是构建更复杂数据结构的基础，意味着它们往往是一个最小化原子类型，无法解构为其它类型(一般意义上来说)。以下是一些常见的基本数据类型及其简要说明：

1. 整型（Integer）：整数类型表示整数。根据位数和有无符号，它们分为以下几种：
   - `i8`, `i16`, `i32`, `i64`, `i128`: 分别表示 8、16、32、64 和 128 位的有符号整数。
   - `u8`, `u16`, `u32`, `u64`, `u128`: 分别表示 8、16、32、64 和 128 位的无符号整数。
   - `isize`, `usize`: 用于表示内存地址或容量的整数类型。它们的位数取决于目标平台的指针大小（例如，64 位平台上的 `isize` 和 `usize` 是 64 位的）。
2. 浮点型（Floating-Point）：浮点类型用于表示实数。Rust 中有两种浮点类型：
   - `f32`: 32 位单精度浮点数。
   - `f64`: 64 位双精度浮点数（默认浮点类型）。
3. 布尔型（Boolean）：布尔类型表示逻辑真或假。它有两个值：
   - `true`: 真。
   - `false`: 假。
4. 字符型（Character）：字符类型表示一个 Unicode 标量值。字符字面量用单引号表示，例如：`'a'`、`'1'` 或 `'😊'`。
5. 元组（Tuple）：元组是一个有限长度的有序列表，可以包含不同类型的元素。元组类型使用圆括号表示，例如：`(i32, f64, bool)`。元组字面量也使用圆括号，例如：`(1, 2.0, true)`。
6. 数组（Array）：数组是一个固定长度的有序列表，包含相同类型的元素。数组类型使用方括号表示，例如：`[i32; 5]`。数组字面量也使用方括号，例如：`[1, 2, 3, 4, 5]`。

这些基本数据类型为 Rust 提供了强大的基础，使得程序员可以构建各种复杂的数据结构和算法。此外，Rust 标准库还提供了许多其他有用的数据类型，如字符串（`String` 和 `&str`）、向量（`Vec<T>`）以及各种集合类型（如 `HashMap<K, V>` 和 `HashSet<T>`）。

> 与 Python、JavaScript 等动态语言不同，Rust 是一门静态类型语言，也就是编译器必须在编译期知道我们所有变量的类型，但这不意味着你需要为每个变量指定类型，因为 **Rust 编译器很聪明，它可以根据变量的值和上下文中的使用方式来自动推导出变量的类型**，同时编译器也不够聪明，在某些情况下，它无法推导出变量类型，需要手动去给予一个类型标注，



>字符(char): Rust 的字符不仅仅是 `ASCII`，所有的 `Unicode` 值都可以作为 Rust 字符，包括单个的中文、日文、韩文、emoji 表情符号等等，都是合法的字符类型。
>
>由于 `Unicode` 都是 4 个字节编码，因此字符类型也是占用 4 个字节.
>
><font color=red>注意：单引号表示一个 `char` 类型的值.  双引号表示一个字符串字面量，其类型为 `&str`。`&str` 类型是一个字符串切片（string slice），表示对一个 UTF-8 编码的字符串数据的引用。</font>



>布尔(bool): Rust 中的布尔类型有两个可能的值：`true` 和 `false`，布尔值占用内存的大小为 `1` 个字节.



>单元类型（unit type）: 表示一个空元组，写作 `()`。单元类型用于表示没有任何有意义的值或数据的情况



#### 整数类型

**整数**是没有小数部分的数字。之前使用过的 `i32` 类型，表示有符号的 32 位整数（ `i` 是英文单词 *integer* 的首字母，与之相反的是 `u`，代表无符号 `unsigned` 类型）。

每个有符号类型规定的数字范围是 -(2n - 1) ~ 2n - 1 - 1，其中 `n` 是该定义形式的位长度。因此 `i8` 可存储数字范围是 -(27) ~ 27 - 1，即 -128 ~ 127。无符号类型可以存储的数字范围是 0 ~ 2n - 1，所以 `u8` 能够存储的数字为 0 ~ 28 - 1，即 0 ~ 255。

此外，`isize` 和 `usize` 类型取决于程序运行的计算机 CPU 类型： 若 CPU 是 32 位的，则这两个类型是 32 位的，同理，若 CPU 是 64 位，那么它们则是 64 位。



> 在 Rust 中声明一个整数变量并使用整数字面量赋值时，如果没有指定类型，编译器会默认将其推断为 `i32` 类型。



##### 整数溢出

假设有一个 `u8` ，它可以存放从 0 到 255 的值。那么当你将其修改为范围之外的值，比如 256，则会发生**整型溢出**。关于这一行为 Rust 有一些有趣的规则：当在 debug 模式编译时，Rust 会检查整型溢出，若存在这些问题，则使程序在编译时 *panic*(崩溃,Rust 使用这个术语来表明程序因错误而退出)。

在当使用 `--release` 参数进行 release 模式构建时，Rust **不**检测溢出。相反，当检测到整型溢出时，Rust 会按照补码循环溢出（*two’s complement wrapping*）的规则处理。简而言之，大于该类型最大值的数值会被补码转换成该类型能够支持的对应数字的最小值。比如在 `u8` 的情况下，256 变成 0，257 变成 1，依此类推。程序不会 *panic*，但是该变量的值可能不是你期望的值。依赖这种默认行为的代码都应该被认为是错误的代码。



#### 浮点类型

**浮点类型数字** 是带有小数点的数字，在 Rust 中浮点类型数字也有两种基本类型： `f32` 和 `f64`，分别为 32 位和 64 位大小。默认浮点类型是 `f64`，在现代的 CPU 中它的速度与 `f32` 几乎相同，但精度更高。

> 在 `f64` 类型进行运算时，因为 `f64` 精度高很多，因此在小数点非常后面发生了一点微小的变化。
>
> 所以需要添加精确到几位：`(0.1_f64 + 0.2 - 0.3).abs() < 0.00001`

#### 序列

Rust 提供了一个非常简洁的方式，用来生成连续的数值，例如 `1..5`，生成从 1 到 4 的连续数字，不包含 5 ；`1..=5`，生成从 1 到 5 的连续数字，包含 5，它的用途很简单，常常用于循环中：

```rust
#![allow(unused)]
fn main() {
for i in 1..=5 {
    println!("{}",i);
}
```



序列只允许用于数字或字符类型，原因是：它们可以连续，同时编译器在编译期可以检查该序列是否为空，字符和数字值是 Rust 中仅有的可以用于判断是否为空的类型。如下是一个使用字符类型序列的例子：

```rust
for i in 'a'..='z' {
    println!("{}",i);
}
```







#### 位运算



Rust 提供了一系列位运算符，允许你直接操作整数类型的位。位运算符在底层硬件上通常非常高效，可用于实现位操作相关的算法或进行优化。以下是 Rust 中的位运算符及其说明：

1. 按位与（Bitwise AND）：`&`

   - 对两个整数进行按位与操作。当两个相应的位都为 1 时，结果位才为 1，否则为 0

   ```rust
   // 0b 前缀表示这是一个二进制数，后面的数字表示其二进制值。
   let x = 0b1100;
   let y = 0b1010;
   let z = x & y;
   println!("x & y = {:b}", z); // 输出 "x & y = 1000"
   
   ```

2. 按位或（Bitwise OR）：`|`

   - 对两个整数进行按位或操作。当两个相应的位中至少有一个为 1 时，结果位为 1，否则为 0。

   ```rust
   // 0b 前缀表示这是一个二进制数，后面的数字表示其二进制值。
   let x = 0b1100;
   let y = 0b1010;
   let z = x | y;
   println!("x | y = {:b}", z); // 输出 "x | y = 1110"
   
   ```

3. 按位异或（Bitwise XOR）：`^`

   - 对两个整数进行按位异或操作。当两个相应的位不相同时，结果位为 1，否则为 0。

   ```rust
   // 0b 前缀表示这是一个二进制数，后面的数字表示其二进制值。
   let x = 0b1100;
   let y = 0b1010;
   let z = x ^ y;
   println!("x ^ y = {:b}", z); // 输出 "x ^ y = 110"
   
   ```

4. 按位非（Bitwise NOT）：`!`

   - 对一个整数进行按位非操作。将整数的每一位取反，即 0 变为 1，1 变为 0。

   ```rust
   // 0b 前缀表示这是一个二进制数，后面的数字表示其二进制值。
   let x = 0b1100;
   let z = !x;
   println!("!x = {:b}", z); // 输出 "!x = 11111111111111111111111111110011"（32位整数）
   
   ```

5. 左移（Left Shift）：`<<`

   - 将整数的位向左移动指定的位数。右侧空出的位用 0 填充。

   ```rust
   // 0b 前缀表示这是一个二进制数，后面的数字表示其二进制值。
   let x = 0b1100;
   let z = x << 2;
   println!("x << 2 = {:b}", z); // 输出 "x << 2 = 110000"
   
   ```

6. 逻辑右移（Logical Right Shift）：`>>`

   - 将整数的位向右移动指定的位数。左侧空出的位用符号位填充（对于无符号整数，符号位为 0）。

   ```rust
   // 0b 前缀表示这是一个二进制数，后面的数字表示其二进制值。
   let x = 0b1100;
   let z = x >> 2;
   println!("x >> 2 = {:b}", z); // 输出 "x >> 2 = 11"
   
   ```



>在 Rust 中，不同进制的整数在进行运算时会被统一为相同的内部表示。实际上，不管你使用哪种进制表示整数，它们都会在内存中以二进制形式存储。因此，当你在 Rust 中使用不同进制的整数进行运算时，它们会自动转换为相应的十进制值，然后再进行计算。运算的结果也是一个整数，通常以十进制形式表示。



### 语句和表达式

语句（Statement）和表达式（Expression）是两个不同的概念，它们之间的主要区别在于是否具有返回值。



语句（Statement）是一条执行操作的指令，它没有返回值，只是对程序状态进行修改。例如，`let` 语句就是一条典型的语句，它声明一个变量并为其赋值，但本身并不返回任何值。

表达式（Expression）则是一个计算结果的操作，它具有返回值。例如，一个简单的加法操作 `1 + 2` 就是一个表达式，它的返回值是 `3`。函数调用也是一个表达式，它的返回值是函数最后一条语句的值。



在 Rust 中，除了语句和表达式的区别之外，它们在语法上的使用也略有不同。例如，在 `if` 表达式中，必须使用表达式来定义条件，因为它需要有返回值。而在函数体中，我们可以使用语句或表达式来执行操作，具体取决于我们需要什么样的返回值和操作。



下面是一个简单的例子，展示了语句和表达式的不同：

```rust
fn main() {
    // 语句
    let x = 10;
    
    // 表达式
    let y = {
        let a = 1;
        let b = 2;
        a + b // 最后一条语句的值是表达式的值
    };
    
    println!("x = {}, y = {}", x, y);
}

//在上面的例子中，我们使用了一个块表达式来计算变量 y 的值，其中块中的最后一条语句 a + b 是一个表达式，其值被作为块的返回值赋给变量 y。
```



>`let` 既可以是语句也可以是表达式，这取决于它的使用方式。当它被用作语句时，它会将一个值绑定到一个变量上.

>最后，表达式如果不返回任何值，会隐式地返回一个 [`()`](https://course.rs/basic/base-type/char-bool.html#单元类型) 。









### 函数

函数（function）是一段可复用的代码块，它可以接收输入参数并返回结果。

函数本身可以看作是一个值，因此也可以被视为表达式。

```rust
fn function_name(param1: Type1, param2: Type2) -> ReturnType {
    // 函数体，这里是一段可执行代码
}

```



 	1. `fn`  关键字:
 	2. `function_name` 是函数的名称
 	3. `param1: Type1, param2: Type2` 是函数的参数列表
 	4. `ReturnType` 是函数的返回类型，
 	5. 函数体则是函数的具体实现。



#### 要点

- 函数名和变量名使用蛇形命名法(snake case)，例如 `fn add_two() -> {}`
- 函数的位置可以随便放，Rust 不关心我们在哪里定义了函数，只要有定义即可
- 每个函数参数都需要标注类型





无返回值：()

在 Rust 中，函数即使没有明确的返回值，它们仍然会返回一个特殊的类型 `()`，也称为“unit”类型。它只有一个值，即 `()`.

- 函数没有返回值，那么返回一个 `()`
- 通过 `;` 结尾的表达式返回一个 `()`



发散函数（diverging function: 返回值为 ！

是指永远不会返回的函数，例如 Rust 标准库中的 `panic!` 宏。由于这些函数不会返回，所以它们的返回值类型是一个特殊的类型 `!`，称为 never 类型。这个类型没有值，所以无法创建该类型的实例。

```rust
fn foo() -> ! {
    panic!("Something went wrong");
}

// 在调用 foo 函数时，由于函数不会正常返回，所以编译器可以推断出它的返回类型是 !。
```


