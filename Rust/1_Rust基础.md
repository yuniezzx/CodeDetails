### 1.命名规则

 Rust 命名规则的基本指导原则：

1. 变量和函数名: 通常使用小写字母，并使用下划线分隔单词，例如 `my_variable` 和 `print_hello`。
2. 常量名: 使用全大写字母，并使用下划线分隔单词，例如 `PI` 和 `MAX_VALUE`。
3. 类型名: 使用驼峰命名法，首字母大写，例如 `MyStruct` 和 `MyEnum`。
4. 模块名和文件名: 使用小写字母，并使用下划线分隔单词。模块名和文件名通常保持一致，例如模块 `my_module` 对应的文件名为 `my_module.rs`。
5. 泛型参数: 通常使用大写字母表示，例如 `T` 和 `U`。在类型名称中，泛型参数通常紧跟在类型名称之后，例如 `Vec<T>`。
6. 生命周期参数: 生命周期参数的名称通常以 `'` 开头，后面跟一个小写字母，例如 `'a` 和 `'b`。
7. 宏名: 宏名使用小写字母，并使用下划线分隔单词。与函数名类似，但在宏名后加感叹号以表示宏，例如 `my_macro!`。

请注意，这些规则并非强制性的，但遵循这些惯例将有助于保持代码的一致性和可读性。


### 2.变量绑定,覆盖和解构



在 Rust 中，变量绑定是使用 `let` 关键字创建的。当你创建一个新的变量绑定时，你将一个值绑定到一个变量名。默认情况下，Rust 中的变量绑定是不可变的，这意味着一旦你给它们赋值，就不能改变它们的值。然而，**你可以使用 `mut` 关键字使变量绑定可变 ** 。

当你在同一作用域内用相同的变量名创建一个新的变量绑定时，新的变量绑定将“覆盖”或“阴影”先前的绑定。



```rust
fn main() {
    let x = 5;
    println!("x: {}", x);

    let x = x + 1;
    println!("x: {}", x);

    let x = x * 2;
    println!("x: {}", x);
}

```



在 Rust 中，解构允许你将复杂的数据结构分解为更简单的部分。这对于从结构体、元组、枚举等类型中提取值非常有用。通过使用模式匹配，你可以将变量解构为它们的组成部分。



```rust
// 解构元组：

fn main() {
    let tuple = (1, "hello", 3.14);

    let (x, y, z) = tuple;

    println!("x: {}, y: {}, z: {}", x, y, z);
}

```



```rust
// 解构结构体：

enum Animal {
    Dog { name: String, age: u8 },
    Cat { name: String, age: u8 },
}

fn main() {
    let animal = Animal::Dog {
        name: String::from("Max"),
        age: 3,
    };

    match animal {
        Animal::Dog { name, age } => println!("Dog's name: {}, age: {}", name, age),
        Animal::Cat { name, age } => println!("Cat's name: {}, age: {}", name, age),
    }
}
```



在 Rust 解构中，`..` 用于模式匹配中的范围。在解构赋值的情况下，使用 `..` 表示你想要忽略剩余的部分，使用 `_` 来表示我们不关心的值。

```rust
fn main() {
  	let (a, b, c, d, e);
    let (x, _) = (3, 4);
    let [_, y] = [1, 2];
  
  	[c, .., d, _] = [1, 2, 3, 4, 5];

    println!("x: {}, y: {}", x, y);  // x: 3, y: 2
}
```


### 3.变量作用域

变量的作用域是变量绑定在程序中生效的区域。变量作用域遵循块作用域规则，这意味着变量的生命周期从声明它的地方开始，到包含它的最近的块（用大括号 `{}` 包围的区域）结束。

在 Rust 中，内部作用域可以访问外部（包含）作用域中定义的变量。也就是说，如果一个变量在外部作用域中声明，那么在该作用域内的所有内部（嵌套）作用域中，该变量都是可见且可访问的。请注意，这并不意味着你可以在内部作用域中修改外部作用域的不可变变量。

```rust
fn main() {
    let x: i32 = 10;
    {
        let y: i32 = 5;
        println!("x 的值是 {}, y 的值是 {}", x, y);
    }
    let y: i32 = 5;
    println!("x 的值是 {}, y 的值是 {}", x, y); 
}
```


